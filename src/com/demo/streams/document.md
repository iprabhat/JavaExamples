## Streams

### Creating Streams

*Streams from Values*

The `Stream` interface contains the following static methods to create a sequential `Stream` from a single value and multiple values.
1. `<T> Stream<T> of(T t)`
2. `<T> Stream<T> of(T...values)`
3. `<T> Stream<T> ofNullable(T t)`: This method was added to the Stream interface in Java 9. It returns a stream with a single value if the specified value is non-null. Otherwise, it returns an empty stream.

The `Stream.Builder<T>` interface can be used to create stream using builder pattern. The `builder()` static method of the `Stream` interface returns a stream builder.
The `Stream.Builder<T>` interface contains the following methods:
1. `void accept(T t)`
2. `Stream.Builder<T> add(T t)`
3. `Stream<T> build()`

Example:
```java
    Stream<String> stream = Stream.<String>builder()
                                .add("TEST1")
                                .add("TEST2")
                                .add("TEST3")
                                .add("TEST4")
                                .build();
```

The `IntStream` interfaces contain four static methods that let you create IntStream from values:

1. `IntStream of(int value)`
2. `IntStream of(int... values)`
3. `IntStream range(int start, int end)`
4. `IntStream rangeClosed(int start, int end).`

The `of()` methods let you create a `IntStream` by specifying individual values. 
The `range()` and `rangeClosed()` methods produce an `IntStream` that contains ordered integers between the specified start and end. The specified end is exclusive in the `range()` method, whereas it is inclusive in the `rangeClosed()` method.

*Empty Streams*
1. An empty stream is a stream with no elements. The Stream interface contains an empty() static method to create an empty sequential stream.
```java
    // It creates an empty stream of strings
    Stream<String> stream = Stream.empty();
```

2. The `IntStream`, `LongStream`, and `DoubleStream` interfaces also contain an `empty()` static method to create an empty stream of primitive types. For example:
```java
    // It creates an empty stream of integers
    IntStream numbers = IntStream.empty();
```

*Streams from Functions*

The Stream interface contains the following two static methods to generate an infinite stream:
1. `<T> Stream<T> iterate(T seed, Predicate<? super T> hasNext, UnaryOperator<T> next)`
2. `<T> Stream<T> iterate(T seed, UnaryOperator<T> f)`
3. `<T> Stream<T> generate(Supplier<? extends T> s)`

The `iterate()` method creates a sequential ordered stream, whereas the `generate()` method creates a sequential unordered stream.

Using the `Stream.iterate()` Method

`static <T> Stream<T> iterate(T seed, Predicate<? super T> hasNext, UnaryOperator<T> next)`: The method takes three arguments: a seed, a predicate, and a function. It produces elements by iteratively applying the next function as long as the hasNext predicate is true. The seed argument is the initial element.

The following snippet of code produces a stream of integers from 1 to 10:

```java
Stream<Integer> nums = Stream.iterate(1, n -> n <= 10, n -> n + 1);
```

The second version of the `iterate()` method is declared as follows:

`static <T> Stream<T> iterate(T seed, UnaryOperator<T> f)`: The method takes two arguments: a seed and a function. The first argument is a seed that is the first element of the stream. The second element is generated by applying the function to the first element. The third element is generated by applying the function on the second element and so on. Its elements are seed, 
f(seed), f(f(seed)), f(f(f(seed))), and so on.

The following statement creates an infinite stream of natural numbers and an infinite stream of all odd natural numbers:
```java
    // Creates a stream of natural numbers
    Stream<Long> naturalNumbers = Stream.iterate(1L, n -> n + 1);
    // Creates a stream of odd natural numbers
    Stream<Long> oddNaturalNumbers = Stream.iterate(1L, n -> n + 2);
```

We can apply the limit operation using the `limit(long maxSize)` method of the Stream interface. The following snippet of code creates a stream of the first 10 natural numbers: 
```java    
    // Creates a stream of the first 10 natural numbers
    Stream<Long> tenNaturalNumbers = Stream.iterate(1L, n -> n + 1)
    .limit(10);
 ```

 Using the `Stream.generate()` Method

 The `generate(Supplier<? extends T> s)` method uses the speccified supplier to generate an infinite sequential unordered stream.
 The following generates 5 random numbers:
 ```java
    Stream.generate(Math::random)
    .limit(5)
    .forEach(System.out::println);
 ```

*Streams from Arrays*

The `Arrays` class in the contains an overloaded `stream()` static method to create sequential streams from arrays. 
It can be used to create an `IntStream` from an `int` array, a `LongStream` from `long` array, a `DoubleStream` from a `double` array, and a `Stream<T>` from an array of the reference type `T`.

```java
// Creates a stream from an int array
IntStream numbers = Arrays.stream(new int[]{1, 2, 3, 4 ,5});
// Creates a stream from a String array 
Stream<String> names = Arrays.stream(new String[] {"ABC", "XYZ", "PQR"});
```

*Streams from Collections*

The Collection interface contains the `stream()` and `parallelStream()` methods that create sequential and parallel streams from a Collection, respectively.

*Streams from Files*

The BufferedReader and Files classes contain a `lines()` method that reads a file lazily and returns the contents as a stream of strings. Each element in the stream represents one line of text from the file.

Examples
```java
    Path path = Paths.get(filePath);
    try (Stream<String> lines = Files.lines(path)) {
        lines.forEach(System.out::println);
    }
    catch (IOException e) {
        e.printStackTrace();
    }
```

*Stream from other sources*

1. The `chars()` method in the `CharSequence` interface returns an `IntStream` whose elements are `int` values representing the characters of the `CharSequence`. The `chars()` method can be used on a `String`, a `StringBuilder`, and a `StringBuffer`
to obtain a stream of characters as these classes implement the `CharSequence` interface.
2. The `splitAsStream(CharSequence input)` method of the `java.util.regex.Pattern` class returns a stream of `String` whose elements match the pattern.

Examples:
```java
    String str = "Hello World";
    str.chars()    
    .forEach(n -> System.out.print((char)n));


    String str = "ABC,PQR,XYZ";
    Pattern.compile(",")
        .splitAsStream(str)
        .forEach(System.out::println);
```

### Optional Values

An `Optional` is a container object that may or may not contain a non-null value. 
Its `isPresent()` method returns `true` if it contains a non-null value, and `false` otherwise. 
The `get()` method returns the non-null value if it contains a non-null value, and throws a `NoSuchElementException` otherwise.

Creating optional objects:

1. `<T> Optional<T> empty()`: Returns an empty Optional. That is, the Optional returned from this method does not contain a non-null value.
2. `<T> Optional<T> of(T value)`: Returns an Optional containing the specified value as the non-null value. If the specified value is null, it throws a `NullPointerException`.
3. `<T> Optional<T> ofNullable(T value)`: Returns an `Optional` containing the specified value if the value is non-null. If the specified value is null, it returns an empty `Optional`.

Example:

```java
    // Create an empty Optional
    Optional<String> empty = Optional.empty();

    // Create an Optional for the string "Hello World"
    Optional<String> str = Optional.of("Hello World");
    
    // Create an Optional with a String that may be null
    String nullableString = ""; // get a string that may be null...
    Optional<String> str2 = Optional.of(nullableString);

    // Create an Optional for the string "Hello"
    Optional<String> str = Optional.of("Hello");
    // Print the value in Optional
    if (str.isPresent()) {
        String value = str.get();
        System.out.println("Optional contains " + value);
    } else {
        System.out.println("Optional is empty.");
    }
```

The `ifPresent(Consumer<? super T> action)` method of the `Optional` class can be used to take an action on the value contained in the `Optional` object.

Example:

```java
    // Create an Optional for the string "Hello"
    Optional<String> str = Optional.of("Hello");
    // Print the value in the Optional, if present
    str.ifPresent(value -> System.out.println("Optional contains " + value));
```

The following are four methods to get the value of an `Optional`:
1. `T get()`: Returns the value contained in the Optional. If the Optional is empty, it throws a `NoSuchElementException`.
2. `T orElse(T defaultValue)`: Returns the value contained in the `Optional`. If the `Optional` is empty, it returns the specified defaultValue.
3. `T orElseGet(Supplier<? extends T> defaultSupplier)`: Returns the value contained in the `Optional`. If the `Optional` is empty, it returns the value returned from the specified defaultSupplier.
4. `<X extends Throwable> T orElseThrow(Supplier<? extends X> exceptionSupplier) throws X extends Throwable`: Returns the value contained in the `Optional`. If the `Optional` is empty, it throws the exception returned from the specified exceptionSupplier.


### Various Stream Operations

*Intermediate Operations*

1. `distinct` Intermediate Returns a stream consisting of the distinct elements of this stream. Elements e1 and e2 are considered equal if e1.equals(e2) returns true.

2. `filter` Intermediate Returns a stream consisting of the elements of this stream that match the specified predicate.

3. `limit` Intermediate Returns a stream consisting of the elements in this stream, truncated to be no longer than the specified size.

4. `map` Intermediate Returns a stream consisting of the results of applying the specified function to the elements in this stream. Performs one-to-one mapping.

5. `flatMap` Intermediate Returns a stream consisting of the results of applying the specified function to the elements in this stream. The function produces a stream for each input element and the output streams are flattened. Performs one-to-many mapping.

6. `peek` Intermediate Returns a stream whose elements consist of this stream. It applies the specified action as it consumes elements of this stream. It is mainly used for debugging purposes.

7. `skip` Intermediate Discards the first N elements in the stream and returns the remaining stream. If this stream contains fewer than N elements, an empty stream is returned.

8. `dropWhile` Intermediate Returns the elements of the stream, discarding the elements from the beginning for which a predicate is true. This operation was added to the Streams API in Java 9.

9. `takeWhile` Intermediate Returns elements from the beginning of the stream, which match a predicate, discarding the rest of the elements. This operation was added to the Streams API in Java 9.

10. `sorted` Intermediate Returns a stream consisting of the elements in this stream, sorted according to natural order or the specified Comparator. For an ordered stream, the sort is stable.

*Terminal Operations*

1. `allMatch` Terminal Returns true if all elements in the stream match the specified predicate, false otherwise. Returns true if the stream is empty.

2. `anyMatch` Terminal Returns true if any element in the stream matches the specified predicate, false otherwise. Returns false if the stream is empty.

3. `findAny` Terminal Returns any element from the stream. An empty Optional is returned for an empty stream.

4. `findFirst` Terminal Returns the first element of the stream. For an ordered stream, it returns the first element in the encounter order; for an unordered stream, it returns any element.

5. `noneMatch` Terminal Returns true if no elements in the stream match the specified predicate, false otherwise. Returns true if the stream is empty.

6. `forEach` Terminal Applies an action for each element in the stream.

7. `reduce` Terminal Applies a reduction operation to compute a single value from the stream.

### Collecting Summary Statistics

The `java.util` package contains the following classes to collect statistics.

1. `DoubleSummaryStatistics`
2. `LongSummaryStatistics`
3. `IntSummaryStatistics`

Example
```java
    DoubleSummaryStatistics stats = new DoubleSummaryStatistics();
    stats.accept(100.0);
    stats.accept(200.0);
    stats.accept(300.0);
    // Get stats
    long count = stats.getCount();
    double sum = stats.getSum();
    double min = stats.getMin();
    double avg = stats.getAverage();
    double max = stats.getMax();
    System.out.printf("count=%d, sum=%.2f, min=%.2f, max=%.2f, average=%.2f%n", count, sum, min, max, avg);
```

The Sumamry Statistics used in `Stream`
```java
    List<Person> lst = ...
    DoubleSummaryStatistics incomeStats = lst.stream()
        .map(Person::getIncome)
        .collect(DoubleSummaryStatistics::new,
            DoubleSummaryStatistics::accept,
            DoubleSummaryStatistics::combine);

    System.out.println(incomeStats);
```
The `Collectors` class contains methods to obtain a collector to compute the summary statistics of the specific type of numeric data. The methods are named `summarizingDouble()`, `summarizingLong()`, and `summarizingInt()`. They take a function to be applied on the elements of the stream and return a `DoubleSummaryStatistics`, a `LongSummaryStatistics`, and an `IntSummaryStatistics`, respectively. The previous code example can be re-written as follows:

```java
    List<Person> lst = ...
    DoubleSummaryStatistics incomeStats = lst.stream()
        .collect(Collectors.summarizingDouble(Person::getIncome));
    System.out.println(incomeStats);
```

### Collecting Data in Maps

The `toMap()` method of the `Collectors` class can be used to return a collector to collect data in `Map`. The following three overloaded methods are available.

1. `toMap(Function<? super T,? extends K> keyMapper, Function<? super T,? extends U> valueMapper)`
2. `toMap(Function<? super T,? extends K> keyMapper, Function<? super T,? extends U> valueMapper, BinaryOperator<U> mergeFunction)`
3. `toMap(Function<? super T,? extends K> keyMapper, Function<? super T,? extends U> valueMapper, BinaryOperator<U> mergeFunction, Supplier<M> mapSupplier)`

### Joining String Using Collectors

The `joining()` method of the `Collectors` class returns a collector that concatenates the elements of a stream of `CharSequence` and returns the result as a `String`.

The `joining()` method is overloaded and it has three versions:

1. `joining()`
2. `joining(CharSequence delimiter)`
3. `joining(CharSequence delimiter, CharSequence prefix, CharSequence suffix)`

### Grouping Data

The `groupingBy()` method of the `Collectors` class returns a collector that groups the data before collecting them in a Map.

The groupingBy() method is overloaded and it has three versions:

1. `groupingBy(Function<? super T,? extends K> classifier)`
2. `groupingBy(Function<? super T,? extends K> classifier, Collector<? super T,A,D> downstream)`
3. `groupingBy(Function<? super T,? extends K> classifier, Supplier<M> mapFactory, Collector<? super T,A,D> downstream)`

### Partitioning Data

Partitioning collects data into two groups: for one group a condition is `true`; for the other, the same condition is `false`. The partitioning condition is specified using a `Predicate`.

The method is called `partitioningBy()` and it's overloaded versions are as follows:
1. `partitioningBy(Predicate<? super T> predicate)`
2. `partitioningBy(Predicate<? super T> predicate, Collector<? super T,A,D> downstream)`

Like the `groupingBy()` method, the `partitioningBy()` method also collects data in a `Map` whose keys are always of the type Boolean. 
The `Map` returned from the collector always contains two entries: one with the key value as `true` and another with the key value as `false`.

### Adapting the Collector Results

There is one more type of collector that collects the data and lets you modify the result before and after collecting the data. The result of the collector can be adapted to a different type; the elements can be filtered after they are grouped but before they are collected; the elements can be mapped as they are grouped, but before they are collected. The following static methods in the Collectors class return such collectors:

1. `<T,A,R,RR> Collector<T,A,RR> collectingAndThen(Collector<T,A,R> downstream, Function<R,RR> finisher)`
2. `<T,A,R> Collector<T,?,R> filtering(Predicate<? super T> predicate, Collector<? super T,A,R> downstream)`
3. `<T,U,A,R> Collector<T,?,R> flatMapping(Function<? super T,? extends Stream<? extends U>> mapper, Collector<? super U,A,R> downstream)`

### Parallel Streams

Operations on a sequential stream are processed in serial using one thread. Operations on a parallel stream are processed in parallel using multiple threads.
Most of the methods in the Streams API produce sequential streams by default. To produce a parallel stream from a collection, such as a `List` or a `Set`, you need to call the `parallelStream()` method of the `Collection` interface. Use the `parallel()` method on a stream to convert a sequential stream into a parallel stream. Conversely, use the `sequential()` method on a stream to convert a parallel stream into a sequential stream.

1. The Streams API uses the Fork/Join framework to process parallel streams. The Fork/Join framework uses multiple threads. It divides the stream elements into chunks; each thread processes a chunk of elements to produce a partial result, and the partial results are combined to give you the result. 

2. Starting up multiple threads, dividing the data into chunks, and combining partial results takes up CPU time. This overhead is justified by the overall time to finish the task. For example, a stream of six people is going to take longer to process in parallel than in serial. The overhead of setting up the threads and coordinating them for such a small amount of work is not worth it. 

3. You have seen the use of an Iterator for traversing elements of collections. The Streams API uses a `Spliterator` (a splittable iterator) to traverse elements of streams. `Spliterator` is a generalization of `Iterator`. An iterator provides sequential access to data elements. 

4. A `Spliterator` provides sequential access and decomposition of data elements. When you create a `Spliterator`, it knows the chunk of data it will process. You can split a `Spliterator` into two: each will get its own chunk of data to process. The `Spliterator` is an interface in the `java.util` package. It is used heavily for splitting stream elements into chunks to be processed by multiple threads. As the user of the Streams API, you will never have to work directly with a Spliterator. The data source of the streams provides a `Spliterator`. 

5. Parallel processing of a stream is faster if the `Spliterator` can know the size of the streams. Streams can be based on a data source that may have a fixed size or an unknown size. Splitting the stream elements into chunks is not possible if the size of the stream cannot be determined. In such cases, even though you can use a parallel stream, you may not get the benefits of parallelism. 

6. Another consideration in parallel processing is the ordering of elements. If elements are ordered, threads need to keep the ordering at the end of the processing. If ordering is not important for you, you can convert an ordered stream into an unordered stream using the `unordered()` method. 

7. `Spliterators` divide the data elements into chunks. It is important that the data source for the stream does not change during stream processing; otherwise the result is not defined. For example, if your stream uses a list/set as the data source, do not add or remove elements from the list/set when the stream is being processed. Stream processing is based on functional programming that does not modify data elements during processing. It creates new data elements rather than modifying them. The same rule holds for stream processing, particularly when it is processed in parallel. The operations in a stream pipeline are specified as lambda expressions that should not modify the mutable states of the elements being processed.

